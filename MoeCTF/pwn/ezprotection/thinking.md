拿到题目先checksec，保护全开。

利用ida进行分析

第一个read可以泄露canary的值，第二个read可以溢出，但是只能溢出10字节，无招了。

查看字符串，有后门函数，可以读取flag。但是无法溢出到返回地址。

又遇见知识盲区了。看看别人是怎么溢出的。

看了别人的题解，这题考查的是pie和canary知识点。问了一下ai。

1.先来说一下canary，为了防止栈溢出，程序会在缓冲区和基地址之间设置一个随机数值。32位程序是4字节，64位的程序是8字节。

canary的结尾是\x00，目的是防止canary的值泄露，使用\x00结尾会进行截断。

位置关键： Canary 位于 局部变量（Buffer） 和 栈底指针（RBP/EBP） 之间。

栈布局通常为：[Buffer] -> [Canary] -> [Saved RBP] -> [Return Address]。

随机性： 每次程序运行时，Canary 的值都是随机生成的（除非由 fork() 产生的子进程，Canary 会继承父进程的值）。

首字节截断（截断字符）： 在 Linux 环境下，Canary 的最低位字节（小端序的第一个字节）通常是 \x00。

目的： 防止攻击者利用 printf 或 puts 等字符串函数直接打印出 Canary（因为 C 语言字符串遇到 \x00 会截断）。

检测机制： 函数返回前，程序会检查栈上的 Canary 值是否被修改。如果被修改，程序会调用 __stack_chk_fail 函数，打印 *** stack smashing detected *** 并强制终止，从而阻止后续的返回地址劫持。

2.pie可以让程序加载到内存的任意位置。它是 ASLR（地址空间布局随机化）在二进制代码段上的延伸。

基址随机（Random Base）： 开启 PIE 后，程序代码段（.text）、数据段（.data, .bss）、只读数据段（.rodata）的加载基地址在每次运行时都是随机的。

对比： 没有 PIE (No-PIE) 时，64位 Linux 程序默认基址通常是 0x400000，攻击者可以直接使用硬编码地址。

偏移固定（Constant Offset）： 虽然基地址（Base）在变，但程序内部各个函数、变量之间的相对距离（Offset）是固定不变的。

公式：Real_Address = Base_Address + Offset

3.常见绕过 / 利用特点
泄露基址（Leak Base）： 这是对抗 PIE 的核心。

你需要利用漏洞（如格式化字符串、部分溢出读取栈上残留数据）泄露一个程序内部的指针（例如栈上保存的返回地址，或者 GOT 表中的地址）。

一旦泄露了一个真实地址，减去它在 IDA 中的静态偏移，就能算出 Base_Address。

Partial Overwrite（部分覆盖）：

因为地址的低 12 位（即一页 4KB 内部的偏移）通常是不受随机化影响的。

如果只需要跳转到非常近的地方，可以只覆盖返回地址的最低 1-2 个字节，以此进行 "盲打"（有一定的爆破概率）。

下面我们开始做题，无法泄露基地址，看了只能使用第二种方法进行爆破了。

payload = b'a'*24 + canary + b'a'*8 + p16(0x127D)
返回地址填读取flag的偏移地址。

寻找程序基址 (Base Address) 从 vmmap 中可以看到，程序加载的起始地址（Offset 为 0 的部分）是： 0x5587e9c4b000

0x5587e9c4是固定的，b正是我们需要爆破的，27d可以看成固定偏移
